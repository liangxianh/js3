### 函数表达式

> 1. 函数创建方式 

1. 函数声明：会进行提升，不要在if(){}else(){}内部运用该方式对同名函数进行不同的定义，是无效的语法，会产生错误；
2. 函数表达式：不会进行提升

> 2. 递归
 
1. 不要使用函数名进行递归，可以使用arguments.callee(num-1)（严格模式下不可以使用该方法，会报错）
2. 严格模式下使用命名函数表达式
    var factorial = (function f(num){
        if (num <= 1){
            return 1;
        } else {
            return num * f(num-1);
        }
      });
      
> 3. 闭包

1. 是指有权访问另一个作用域变量的函数
2. 创建方式：内部函数作为外部函数的返回值
3. 内部函数之所以可以访问外部函数，是因为外部函数的作用域在内部函数的作用域链中，作用域链本质上是一个指向变量对象的指针列表，它只
引用但不实际包含变量对象。
4. 一般讲，局部函数在执行完毕之后，局部活动对象就会被销毁，内存中仅保存全局作用域，而闭包不同，闭包会引用外部函数的变量；
5. 当创建的函数被引用完，之后置空null，即解除对内部匿名函数的调用时，闭包的外部活动对象才会被销毁
6. 由于闭包携带包含他的函数的作用域，会占用更多的内存，尽量不要过多的使用；
    
> 4. 闭包与变量

1. 存在的问题：闭包只能取得包含函数中任何变量的最后一个值（如for循环的变量i）
2. 解决的方法：将执行的结果进行返回就可以了；
    function createFunctions(){
        var result = new Array();
        for (var i=0; i < 10; i++){
          result[i] = function(){
              return i;    -->
         };
        }
      return result;
    }
    将for循环内部修改为如下匿名函数立即执行的结果：
    result[i] = function(num){
       return function(){
         return num;
       };
      }(i);
 
> 5. this 

1. 匿名函数的执行环境具有全局性，因此其this 对象通常指向window
2. this 和arguments 也存在同样的问题。如果想访问作用域中的arguments 对象，必须将对该对象的引用保存到另一个闭包能够访问的变量中
 
> 6. 内存泄露

1. 垃圾清理时，运用引用计数方法时，当存在相互循环引用时，将永远不会被回收，（引用完置null），闭包的这种相互引用的情况是存在在，而且外部函数的变量在内部匿名函数一直有使用，不会被清除，所以使用完闭包时，一定将其置null
    
> 7. 用闭包模拟块级作用域
    
1. js语言没有块级作用域，可以通过匿名立即执行函数进行模仿，ES6中引入 let 可以实现块级作用域
2. 又名私有作用域，可以不污染全局环境
   
> 8. 用闭包创建私有变量

1. JavaScript 中没有私有成员的概念；所有对象属性都是公有的，但是有局部变量只说
2. 不足：多查找作用域链中的一个层次，就会在一定程度上影响查找速度。而这正是使用闭包和私有变量的一个显明的不足之处。
    
 > 9. 模块模式
    
1. 可以使用模块模式、增强的模块模式来实现单例的特权方法。    
2. 模块模式（modulepattern）则是为单例创建私有变量和特权方法。所谓单例（singleton），指的就是只有一个实例的对象。按照惯例，JavaScript 是以对象字面量的方式来创建单例对象的    
    
    
    
    
    
    
    
    
